# PostgreSQL & SQL: Data Types

This documentation provides an overview of the data types available in standard SQL and PostgreSQL, highlighting how they work, how they differ, and when to use each one. It also includes practical examples to help you understand their behavior in real database designs.

</br>

## üî¢ Numeric Types

### 1. Numeric - PostgreSQL

| Type               | Description                             |
|:-------------------|:----------------------------------------|
| `SMALLINT`         | Integer range from ‚àí32,768 to 32,767    |
| `INTEGER` / `INT`  | Standard 32‚Äëbit integer                 |
| `BIGINT`           | 64‚Äëbit integer                          |
| `NUMERIC(p,s)`     | Exact decimal, ideal for financial data |
| `DECIMAL(p,s)`     | Alias of NUMERIC in PostgreSQL          |
| `REAL`             | 32‚Äëbit floating‚Äëpoint number            |
| `DOUBLE PRECISION` | 64‚Äëbit floating‚Äëpoint number            |
| `SERIAL`           | Auto‚Äëincrementing (INTEGER)             |
| `BIGSERIAL`        | Auto‚Äëincrementing (BIGINT)              |
| `SMALLSERIAL`      | Auto‚Äëincrementing (SMALLINT)            |

</br>

### 2. Numeric - Standard x PostgreSQL

| Standard SQL             | PostgreSQL              | Notes                                              |
|:-------------------------|:------------------------|:---------------------------------------------------|
| `SMALLINT`               | `SMALLINT`              | Same in both; range ‚àí32,768 to 32,767              |
| `INTEGER` / `INT`        | `INTEGER` / `INT`       | Same in both; 32‚Äëbit integer                       |
| `BIGINT`                 | `BIGINT`                | Same in both; 64‚Äëbit integer                       |
| `NUMERIC(p,s)`           | `NUMERIC(p,s)`          | Fully standard; exact precision; ideal for money   |
| `DECIMAL(p,s)`           | `DECIMAL(p,s)`          | PostgreSQL treats DECIMAL as an alias for NUMERIC  |
| `REAL`                   | `REAL`                  | Standard 32‚Äëbit float                              |
| `DOUBLE PRECISION`       | `DOUBLE PRECISION`      | Standard 64‚Äëbit float                              |
| `GENERATED AS IDENTITY`  | `GENERATED AS IDENTITY` | SQL‚Äëstandard auto‚Äëincrement; preferred over SERIAL |
| (no standard equivalent) | `SERIAL`                | PostgreSQL‚Äëspecific auto‚Äëincrementing INTEGER      |
| (no standard equivalent) | `BIGSERIAL`             | PostgreSQL‚Äëspecific auto‚Äëincrementing BIGINT       |
| (no standard equivalent) | `SMALLSERIAL`           | PostgreSQL‚Äëspecific auto‚Äëincrementing SMALLINT     |

</br>

### 3. Numeric - Example

```sql
CREATE TABLE numeric_examples (
    small_count      SMALLINT,                       -- small integer range
    standard_count   INTEGER,                        -- standard 32-bit integer
    large_count      BIGINT,                         -- large integer range
    price            NUMERIC(10,2),                  -- exact decimal (money)
    discount_rate    DECIMAL(5,4),                   -- same as NUMERIC
    temperature      REAL,                           -- 32-bit float
    precision_score  DOUBLE PRECISION,               -- 64-bit float

    -- PostgreSQL-specific auto-increment types
    id_serial        SERIAL,                         -- auto-incrementing INT
    id_bigserial     BIGSERIAL,                      -- auto-incrementing BIGINT
    id_smallserial   SMALLSERIAL,                    -- auto-incrementing SMALLINT

    -- SQL-standard identity columns (recommended)
    id_identity_always   INTEGER GENERATED ALWAYS AS IDENTITY,
    id_identity_default  BIGINT  GENERATED BY DEFAULT AS IDENTITY
);
```

</br>

## üÜö INTEGER / INT x BIGINT

Notes:

- Both represent whole numbers without decimals.
- INTEGER (or INT) is 32‚Äëbit; BIGINT is 64‚Äëbit.
- Use INTEGER for typical counters and IDs unless you expect extremely large values.
- Use BIGINT for large datasets, analytics, or high‚Äëvolume identifiers.

Similarities:

- Both are exact integer types.
- Both support the same arithmetic operations.
- Both behave the same in indexing, constraints, and performance (except for size).

Differences:

- INTEGER range: ‚àí2,147,483,648 to 2,147,483,647.
- BIGINT range: ‚àí9 quintillion to +9 quintillion.
- BIGINT uses more storage (8 bytes vs 4 bytes).
- BIGINT is safer for large auto‚Äëincrementing IDs.

</br>

## üÜö NUMERIC x DECIMAL x REAL x DOUBLE PRECISION

Notes:

- NUMERIC and DECIMAL are exact precision types.
- REAL and DOUBLE PRECISION are floating‚Äëpoint types with approximate values.
- Use NUMERIC/DECIMAL for money, finance, and exact calculations.
- Use REAL/DOUBLE PRECISION for scientific or statistical workloads.

Similarities:

- NUMERIC and DECIMAL behave identically in PostgreSQL.
- REAL and DOUBLE PRECISION both store approximate values.
- All four types support arithmetic operations and casting.

Differences:

- NUMERIC(p,s) and DECIMAL(p,s) store exact values with user‚Äëdefined precision.
- REAL is 32‚Äëbit floating point; DOUBLE PRECISION is 64‚Äëbit.
- Floating‚Äëpoint types can introduce rounding errors; NUMERIC/DECIMAL do not.
- Floating‚Äëpoint types are faster and use less storage than NUMERIC.

</br>

## üÜö SERIAL x BIGSERIAL x IDENTITY

Notes:

- SERIAL and BIGSERIAL are PostgreSQL‚Äëspecific convenience types.
- They automatically create a sequence and set a default value.
- IDENTITY is SQL‚Äëstandard and preferred for modern PostgreSQL.
- IDENTITY does not create a separate sequence object unless needed.

Similarities:

- All generate auto‚Äëincrementing integer values.
- All can be used as primary keys.
- All integrate with indexes and constraints normally.

Differences:

- SERIAL ‚Üí auto‚Äëincrementing INTEGER.
- BIGSERIAL ‚Üí auto‚Äëincrementing BIGINT.
- IDENTITY ‚Üí SQL‚Äëstandard; supports GENERATED ALWAYS or BY DEFAULT.
- SERIAL creates a separate sequence; IDENTITY ties the sequence to the column definition.

</br>

## üìñ Text Types

### Strings - PostgreSQL

| Type                               | Description                                           |
|:-----------------------------------|:------------------------------------------------------|
| `TEXT`                             | Unlimited length; PostgreSQL‚Äëspecific                 |
| `VARCHAR(n)`                       | Variable length with limit SQL standard               |
| `VARCHAR`                          | Unlimited length; behaves the same as TEXT internally |
| `CHAR(n)`                          | Fixed‚Äëlength, space‚Äëpadded string; rarely recommended |

</br>

### Strings - Standard x PostgreSQL

| Standard SQL             | PostgreSQL   | Notes                                                         |
|:-------------------------|:-------------|:--------------------------------------------------------------|
| `CHAR(n)`                | `CHAR(n)`    | Same behavior; fixed‚Äëlength and padded                        |
| `VARCHAR(n)`             | `VARCHAR(n)` | Same behavior; length‚Äëlimited                                 |
| (no standard equivalent) | `VARCHAR`    | PostgreSQL allows unlimited VARCHAR; not part of SQL standard |
| (no standard equivalent) | `TEXT`       | PostgreSQL‚Äëspecific; unlimited length                         |

</br>

### Strings - Example

```sql
CREATE TABLE text_examples (
    description_text     TEXT,        -- unlimited length
    username_limited     VARCHAR(30), -- max 30 characters
    comment_unlimited    VARCHAR,     -- unlimited, same as TEXT
    country_code         CHAR(2)      -- fixed 2-character code
);
```

</br>

### üÜö TEXT vs VARCHAR in PostgreSQL

Notes:

- PostgreSQL supports both TEXT and VARCHAR for storing variable‚Äëlength strings.
- They behave similarly because PostgreSQL stores them using the same internal mechanism.
- The type VARCHAR is part of the SQL standard, however TEXT is PostgreSQL‚Äëspecific.
- For most PostgreSQL projects, TEXT is preferred unless you need a strict length constraint for business rules.

Similarities:

- Both can store strings of unlimited length (when VARCHAR has no limit).
- Both use the same internal storage representation in PostgreSQL.
- No performance difference in normal usage.

Differences:

- VARCHAR(n) enforces a maximum length. If exceeded, PostgreSQL throws an error.
- TEXT has no length limit.
- VARCHAR(n) performs an extra check to ensure the string fits the limit. This adds a tiny CPU cost.
- TEXT does not validate length.

</br>

### üÜö CHAR(n) x VARCHAR(n)

Notes:

- Both are SQL‚Äëstandard character types.
- CHAR(n) always stores fixed‚Äëlength strings, padding with spaces if needed.
- VARCHAR(n) stores variable‚Äëlength strings up to a maximum limit.
- CHAR(n) is rarely recommended because padding can cause subtle bugs and wasted space.
- VARCHAR(n) is preferred for almost all real‚Äëworld text fields.

Similarities:

- Both enforce a maximum length (n).
- Both are SQL‚Äëstandard and fully supported by PostgreSQL.
- Both store textual data and support the same operators and collations.

Differences:

- CHAR(n) pads values with spaces; VARCHAR(n) does not.
- CHAR(n) always uses the full allocated length; VARCHAR(n) uses only what it needs.
- CHAR(n) can cause unexpected comparison behavior due to trailing spaces.
- VARCHAR(n) is more flexible and efficient for most use cases.

</br>

## üé≠ Boolean Types

### 1. Boolean - PostgreSQL

| Type                               | Description                                |
|:-----------------------------------|:-------------------------------------------|
| `BOOLEAN`                          | Logical value: TRUE, FALSE, or NULL        |

</br>

### 2. Boolean - Standard x PostgreSQL

| Standard SQL             | PostgreSQL                                                | Notes                                        |
|:-------------------------|:----------------------------------------------------------|:---------------------------------------------|
| `BOOLEAN`                | `BOOLEAN`                                                 | Fully compatible; supports TRUE, FALSE, NULL |
| (no other boolean types) | PostgreSQL accepts shorthand values (t, f, 1, 0, yes, no) | Convenience extensions                       |

</br>

### 3. Boolean - Example

```sql
CREATE TABLE boolean_examples (
    is_active      BOOLEAN,              -- TRUE, FALSE, or NULL
    email_verified BOOLEAN NOT NULL,     -- must be TRUE or FALSE
    is_admin       BOOLEAN DEFAULT FALSE -- default value
);

INSERT INTO boolean_examples (is_active, email_verified)
VALUES
    (TRUE, FALSE),
    (FALSE, TRUE),
    (NULL, FALSE); -- NULL represents "unknown" or "not provided"

```

</br>

## üóìÔ∏è Date & Time

### 1. Date & Time - PostgreSQL

| Type                                      | Description                                                       |
|:------------------------------------------|:------------------------------------------------------------------|
| `DATE`                                    | Calendar date (year, month, day)                                  |
| `TIME`                                    | Time of day (hours, minutes, seconds)                             |
| `TIMESTAMP`                               | Date + time (no timezone awareness)                               |
| `TIMESTAMP WITH TIME ZONE (timestamptz)`  | Date + time with timezone; stored in UTC and converted on display |
| `INTERVAL`                                | A span of time (e.g., 3 days, 2 hours)                            |

</br>

### 2. Date & Time - Standard x PostgreSQL

| Standard SQL               | PostgreSQL            | Notes                                                         |
|:---------------------------|:----------------------|:--------------------------------------------------------------|
| `DATE`                     | `DATE`                | Same behavior                                                 |
| `TIME`                     | `TIME`                | Same behavior                                                 |
| `TIMESTAMP`                | `TIMESTAMP`           | Same behavior; no timezone                                    |
| `TIMESTAMP WITH TIME ZONE` | `TIMESTAMPTZ`         | PostgreSQL stores in UTC internally                           |
| `INTERVAL`                 | `INTERVAL`            | PostgreSQL fully supports SQL standard intervals              |
| (no standard equivalent)   | `TIME WITH TIME ZONE` | PostgreSQL supports it, but rarely used                       |

</br>

### 3. Date & Time - Example

```sql
CREATE TABLE date_examples (
    event_date        DATE,        -- calendar date only
    event_time        TIME,        -- time of day
    created_at        TIMESTAMP,   -- date + time (no timezone)
    created_at_tz     TIMESTAMPTZ, -- date + time with timezone
    duration_between  INTERVAL     -- duration or time span
);

INSERT INTO date_examples (
    event_date, event_time, created_at, created_at_tz, duration_between
)
VALUES (
    DATE '2025-01-15',        -- explicit DATE literal
    TIME '14:30:00',          -- explicit TIME literal
    NOW(),                    -- current timestamp (no timezone)
    NOW(),                    -- current timestamp with timezone
    INTERVAL '3 days 4 hours' -- interval literal
);
```

## üÜö TIMESTAMP x TIMESTAMP WITH TIME ZONE x INTERVAL

Notes:

- TIMESTAMP stores date + time without timezone.
- TIMESTAMPTZ stores date + time with timezone, normalized to UTC.
- INTERVAL stores durations, not points in time.
- Use TIMESTAMPTZ for almost all real‚Äëworld timestamps.

Similarities:

- TIMESTAMP and TIMESTAMPTZ both store date + time.
- All support arithmetic operations (e.g., adding intervals).
- All are SQL‚Äëstandard types.

Differences:

- TIMESTAMP does not adjust for timezone; TIMESTAMPTZ does.
- TIMESTAMPTZ converts input to UTC and back to the client timezone.
- INTERVAL cannot represent a specific moment, only a duration.
- INTERVAL supports units like days, hours, months, etc.

</br>

## üñ•Ô∏è Binary Type

### Binary - PostgreSQL

| Type                               | Description                                |
|:-----------------------------------|:-------------------------------------------|
| `BYTEA`                            | Binary data (images, files, blobs)         |

</br>

### Binary - Standard x PostgreSQL

| Standard SQL                 | PostgreSQL                    | Notes                                                                 |
|:-----------------------------|:------------------------------|:----------------------------------------------------------------------|
| `BINARY(n)`                  | (not supported)               | SQL standard fixed‚Äëlength binary; PostgreSQL does not implement it    |
| `VARBINARY(n)`               | (not supported)               | SQL standard variable‚Äëlength binary; PostgreSQL does not implement it |
| (no standard equivalent)     | `BYTEA`                       | PostgreSQL‚Äôs binary type; used instead of BINARY/VARBINARY            |
| `BLOB` (Binary Large Object) | `BYTEA` or `Large Object API` | PostgreSQL supports large objects via a separate LO API               |

</br>

### Binary - Example

```sql
CREATE TABLE binary_examples (
    file_name    VARCHAR(255),  -- original file name
    file_data    BYTEA,         -- raw binary data
);

-- Insert binary data (hex format)
INSERT INTO binary_examples (file_name, file_data)
VALUES (
    'example.png',
    '\x89504E470D0A1A0A'  -- PNG header bytes
);
```

</br>

## üóùÔ∏è JSON Types

### JSON - PostgreSQL

| Type                               | Description                                                  |
|:-----------------------------------|:-------------------------------------------------------------|
| `JSON`                             | Text‚Äëbased JSON; stored exactly as input                     |
| `JSONB`                            | Binary‚Äëparsed JSON; faster for queries, indexing, and search |

</br>

### JSON - Standard x PostgreSQL

| Standard SQL               | PostgreSQL           | Notes                                                                      |
|:---------------------------|:---------------------|:---------------------------------------------------------------------------|
| `JSON`                     | `JSON`               | Standard SQL defines JSON as a text type; PostgreSQL supports it fully     |
| (no standard equivalent)   | `JSONB`              | PostgreSQL‚Äëspecific binary JSON format; optimized for indexing and queries |
| `SQL/JSON Path`            | `jsonpath`           | PostgreSQL implements SQL/JSON path queries (@?, @@)                       |

</br>

### JSON - Example

```sql
CREATE TABLE json_examples (
    raw_json      JSON,                    -- stored as text
    parsed_json   JSONB,                   -- stored in binary form
);

INSERT INTO json_examples (raw_json, parsed_json)
VALUES (
    '{"name": "Alice", "age": 30}',
    '{"name": "Alice", "age": 30, "skills": ["SQL", "Python"]}'
);

-- Querying JSONB fields
SELECT
    parsed_json->>'name' AS name,
    parsed_json->'skills' AS skills_array,
    parsed_json @> '{"age": 30}' AS has_age_30
FROM json_examples;
```

</br>

## ‚ôªÔ∏è UUID Type

### UUID - PostgreSQL

| Type                               | Description                                   |
|:-----------------------------------|:----------------------------------------------|
| `UUID`                             | Universally unique identifier (128‚Äëbit value) |

</br>

### UUID - Standard x PostgreSQL

| Standard SQL             | PostgreSQL            | Notes                                                                                                |
|:-------------------------|:----------------------|:-----------------------------------------------------------------------------------------------------|
| (no standard type)       | `UUID`                                    | PostgreSQL‚Äëspecific type; SQL standard does not define a UUID type               |
| (workaround: `CHAR(36)`) | `UUID`                                    | In SQL standard, UUIDs are often stored as strings; PostgreSQL has a native type |
| (functions not standard) | `gen_random_uuid()`, `uuid_generate_v4()` | PostgreSQL provides functions to generate UUIDstimezone                          |

</br>

### UUID - Example

```sql
CREATE EXTENSION IF NOT EXISTS "uuid-ossp"; -- enables uuid_generate_v4()

CREATE TABLE uuid_examples (
    id_uuid      UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
    session_id   UUID DEFAULT gen_random_uuid(), -- requires pgcrypto
    description  TEXT
);

-- Insert with auto-generated UUIDs
INSERT INTO uuid_examples (description)
VALUES ('First record'), ('Second record');

-- Insert with explicit UUID
INSERT INTO uuid_examples (id_uuid, description)
VALUES ('550e8400-e29b-41d4-a716-446655440000', 'Custom UUID');

```

</br>

## üìö Types of Arrays

### Arrays - PostgreSQL

| Type                      | Description                                         |
|:--------------------------|:----------------------------------------------------|
| `SMALLINT[]`              | Array of small integers                             |
| `INTEGER[]` / `INT[]`     | Array of 32‚Äëbit integers                            |
| `BIGINT[]`                | Array of 64‚Äëbit integers                            |
| `NUMERIC[]` / `DECIMAL[]` | Array of exact decimals                             |
| `REAL[]`                  | Array of 32‚Äëbit floats                              |
| `DOUBLE PRECISION[]`      | Array of 64‚Äëbit floats                              |
| `BOOLEAN[]`               | Array of TRUE/FALSE values                          |
| `DATE[]`                  | Array of calendar dates                             |
| `TIME[]`                  | Array of times of day                               |
| `TIMESTAMP[]`             | Array of date+time values                           |
| `TIMESTAMPTZ[]`           | Array of date+time with timezone                    |
| `INTERVAL[]`              | Array of durations                                  |
| `TEXT[]`                  | Array of text values                                |
| `VARCHAR[]`               | Array of variable‚Äëlength strings                    |
| `CHAR[]`                  | Array of fixed‚Äëlength strings                       |
| `UUID[]`                  | Array of universally unique identifiers             |
| `JSON[]`                  | Array of JSON text values                           |
| `JSONB[]`                 | Array of binary JSON values                         |
| `BYTEA[]`                 | Array of binary data blobs                          |

</br>

### Arrays - Standard x PostgreSQL

| Standard SQL                 | PostgreSQL               | Notes                                                                                  |
|:-----------------------------|:-------------------------|:---------------------------------------------------------------------------------------|
| (no standard equivalent)     | `ARRAY[]`                | PostgreSQL supports arrays natively; SQL standard does not define a general array type |
| (workaround: separate table) | `ARRAY[]`                | In SQL standard, lists are usually modeled with related tables                         |
| (extensions)                 | `ANYARRAY`, `ANYELEMENT` | PostgreSQL provides polymorphic array types for functions                              |

</br>

### Arrays PostgreSQL - Examples

```sql
CREATE TABLE array_examples (
    id              SERIAL PRIMARY KEY,
    numbers         INTEGER[],        -- array of integers
    prices          NUMERIC(10,2)[],  -- array of decimals
    flags           BOOLEAN[],        -- array of booleans
    dates           DATE[],           -- array of dates
    timestamps      TIMESTAMPTZ[],    -- array of timestamps with timezone
    tags            TEXT[],           -- array of text values
    identifiers     UUID[],           -- array of UUIDs
    json_data       JSONB[]           -- array of JSONB documents
);

-- Insert arrays using curly braces
INSERT INTO array_examples (numbers, prices, flags, dates, tags, identifiers, json_data)
VALUES (
    '{1,2,3,4}', 
    '{10.50,20.75,30.00}', 
    '{TRUE,FALSE,TRUE}', 
    '{2025-01-01,2025-01-15}', 
    '{"postgresql","arrays","docs"}',
    '{"550e8400-e29b-41d4-a716-446655440000","123e4567-e89b-12d3-a456-426614174000"}',
    '{"{\"key\":\"value1\"}","{\"key\":\"value2\"}"}'
);
```

```sql
CREATE TABLE array_examples (
    numbers     INTEGER[],   -- array of integers
    tags        TEXT[],      -- array of text values
);

-- Insert arrays using curly braces
INSERT INTO array_examples (numbers, tags)
VALUES (
    '{1,2,3,4,5}', 
    '{"postgresql","arrays","docs"}'
);

-- Query array elements
SELECT
    numbers[1] AS first_number,   -- access first element
    tags[2]    AS second_tag      -- access second element
FROM array_examples;

-- Check if array contains a value
SELECT *
FROM array_examples
WHERE 'postgresql' = ANY(tags);
```

</br>

## üÉè PostgreSQL Special Types

| Type     | Description                                        |
|:---------|:---------------------------------------------------|
| `ENUM`   | Custom enumerated values defined by the user       |
| `CIDR`   | Network address with subnet (e.g., 192.168.0.0/24) |
| `INET`   | IP address (IPv4 or IPv6), with or without subnet  |
| `POINT`  | Geometric point ((x, y))                           |
| `LINE`   | Infinite geometric line                            |
| `CIRCLE` | Circle defined by center point and radius          |

</br>

### Special Types - Example

```sql
-- ENUM type creation
CREATE TYPE mood AS ENUM ('happy', 'sad', 'neutral');

CREATE TABLE special_examples (
    current_mood   mood,   -- custom enumeration
    ip_address     INET,   -- IPv4 or IPv6
    network_block  CIDR,   -- network with subnet
    location_point POINT,  -- (x, y)
    path_line      LINE,   -- infinite line
    area_circle    CIRCLE  -- <(x, y), radius>
);

INSERT INTO special_examples (
    current_mood,
    ip_address,
    network_block,
    location_point,
    path_line,
    area_circle
)
VALUES (
    'happy',
    '192.168.1.10',
    '192.168.1.0/24',
    '(10.5, 20.3)',
    '{1, -1, 0}',     -- line in Ax + By + C = 0 form
    '<(5,5), 3>'      -- circle with center (5,5) and radius 3
);
```

</br>

## üÜö CIDR x INET

Notes:

- Both store IP addresses.
- INET stores a single host address (IPv4 or IPv6).
- CIDR stores a network block (address + subnet).
- PostgreSQL provides operators for subnet containment and comparison.

Similarities:

- Both support IPv4 and IPv6.
- Both support subnet masks.
- Both support indexing and network operators (<<, >>, <<=, etc.).

Differences:

- INET can store an address with or without a subnet.
- CIDR requires a subnet (e.g., /24).
- CIDR enforces network rules; INET does not.
- CIDR is ideal for network ranges; INET for individual hosts.

</br>

## üÜö POINT x LINE x CIRCLE

Notes:

- These are PostgreSQL geometric types.
- Useful for spatial calculations, mapping, and geometric modeling.
- PostgreSQL supports geometric operators like distance, intersection, and containment.

Similarities:

- All represent geometric shapes.
- All support geometric operators (<->, @>, &&, etc.).
- All are PostgreSQL‚Äëspecific (not SQL standard).

Differences:

- POINT represents a coordinate pair (x, y).
- LINE represents an infinite line in the plane.
- CIRCLE represents a center point + radius.
- CIRCLE supports area and containment operations; POINT and LINE do not.

</br>
